
v00

for(HEIGHT){
  for(WIDTH){
      do for every ray:
         - Find closest ray/sphere intersection:
           * Iterate over every sphere

        - For each lightsource that can be reached:
            * Calculate Lambert dot product with material reflection
            * Calculate each colour component, consisting of:
                - Lambert dot product result
                - Per colour intensity of the incoming light

         - Either go with reflected ray or go to next pixel
  }
}
______________________________________________________________________

v0

the first ray we shoot from the eye into the scene is called a primary ray,
visibility ray, or camera ray.

1-check if the ray hits an object 
2-find out how much light it receives by throwing
another ray (called shadow rays) from the hit point to the scene's light


______________________________________________________________________

v1

STEPS:

Scanning the screen
casting rays for good
The closest intersection
Sphere-Ray intersection
Lighting our intersection point
Lambert
Reflection
Phong
Antialiasing



basic pseudo code algo:

for each pixel of the screen {
    Final color = 0;
    Ray = { starting point, direction };
    Repeat
    {
        for each object in the scene
        {
            determine closest ray object/intersection;
        }
        if intersection exists {
            for each light in the scene {
                if the light is not in shadow of another object
                {
                    add this light contribution to computed color;
                }
            }
        }
        Final color = Final color + computed color * previous reflection factor;
        reflection factor = reflection factor * surface reflection property;
        increment depth;
    } until reflection factor is 0 or maximum depth is reached;
}


______________________________________________________________________

v2

Ray Tracing
The basic idea of ray tracing is to pass a ray from the camera's origin,
through the point on the canvas whose colour needs to be determined.
Determine which models get hit by it and pick the closest one,
determine how it's lit to compute the colour there.
This is done by further tracing rays from the hit point to all the light
sources in the scene. If you notice, this approach eliminates the need to
use hidden surface determination algorithms like the back face culling,
z-buffer, etc. since the basic idea is rooted on a hidden surface algorithm
(ray tracing).

There are packages, libraries, etc. that help you do this. However,
it's common that ray tracers are written from scratch as a college-level project.
However, this approach takes more time to render (not to code),
but the results are generally more pleasing than the below one.
This approach is more popular when you want to render non-interactive visuals like movies.




1-For each pixel in the image, it shoots a primary ray into the scene.
The direction of that primary ray is obtained by tracing a line from
the eye to the center of that pixel.

2-Once we have that primary ray's direction set, we check every object
of the scene to see if it intersects with any of them.
(In some cases, the primary ray will intersect more than one object.
When that happens, we select the object whose intersection point
is the closest to the eye. )

3-We then shoot a shadow ray from the intersection point to the light

4- If this particular ray does not intersect an object on its way to
the light, the hit point is illuminated. If it does intersect with
another object, that object casts a shadow on it

If we repeat this operation for every pixel, we obtain a two-dimensional
representation of our three-dimensional scene

STEPS:
The ray-tracing algorithm takes an image made of pixels.
For each pixel in the image, it shoots a primary ray into the scene.
The direction of that primary ray is obtained by tracing a line from the eye to the center of that pixel.
Once we have that primary ray's direction set, we check every object of the scene to see if it intersects with any of them.
In some cases, the primary ray will intersect more than one object. 
When that happens, we select the object whose intersection point is the closest to the eye.

We then shoot a shadow ray from the intersection point to the light.
If this particular ray does not intersect an object on its way to the light, the hit point is illuminated.
      If it does intersect with another object, that object casts a shadow on it (figure 2).
If we repeat this operation for every pixel, we obtain a two-dimensional representation of our three-dimensional scene (figure 3).




for (int j = 0; j < imageHeight; ++j) { 
    for (int i = 0; i < imageWidth; ++i) { 
        // compute primary ray direction
        Ray primRay; 
        computePrimRay(i, j, &primRay); 
        // shoot prim ray in the scene and search for intersection
        Point pHit; 
        Normal nHit; 
        float minDist = INFINITY; 
        Object object = NULL; 
        for (int k = 0; k < objects.size(); ++k) { 
            if (Intersect(objects[k], primRay, &pHit, &nHit)) { 
                float distance = Distance(eyePosition, pHit); 
                if (distance < minDistance) { 
                    object = objects[k]; 
                    minDistance = distance; // update min distance 
                } 
            } 
        } 
        if (object != NULL) { 
            // compute illumination
            Ray shadowRay; 
            shadowRay.direction = lightPosition - pHit; 
            bool isShadow = false; 
            for (int k = 0; k < objects.size(); ++k) { 
                if (Intersect(objects[k], shadowRay)) { 
                    isInShadow = true; 
                    break; 
                } 
            } 
        } 
        if (!isInShadow) 
            pixels[i][j] = object->color * light.brightness; 
        else 
            pixels[i][j] = 0; 
    } 
} 




______________________________________________________________________

v3


Basic Ray Tracing Algorithm

for every pixel {
    cast a ray from the eye
    for every object in the scene
    {
        find intersections with the ray
        keep it if closest
    }
    compute color at the intersection point
}